// Debugger Hook - 绕过无限debugger
(function() {
    // 方法1: Hook Function构造函数
    const originalFunction = Function.prototype.constructor;
    Function.prototype.constructor = function() {
        if (arguments[0] && arguments[0].includes('debugger')) {
            return function() {};
        }
        return originalFunction.apply(this, arguments);
    };

    // 方法2: Hook eval
    const originalEval = window.eval;
    window.eval = function(code) {
        if (code && code.includes('debugger')) {
            code = code.replace(/debugger/g, '');
        }
        return originalEval.call(this, code);
    };

    // 方法3: Hook setInterval/setTimeout (针对定时器触发的debugger)
    const originalSetInterval = window.setInterval;
    window.setInterval = function(fn, delay) {
        if (typeof fn === 'string' && fn.includes('debugger')) {
            return null;
        }
        if (typeof fn === 'function') {
            const fnStr = fn.toString();
            if (fnStr.includes('debugger')) {
                return null;
            }
        }
        return originalSetInterval.apply(this, arguments);
    };

    const originalSetTimeout = window.setTimeout;
    window.setTimeout = function(fn, delay) {
        if (typeof fn === 'string' && fn.includes('debugger')) {
            return null;
        }
        if (typeof fn === 'function') {
            const fnStr = fn.toString();
            if (fnStr.includes('debugger')) {
                return null;
            }
        }
        return originalSetTimeout.apply(this, arguments);
    };

    console.log('[Hook] Debugger Hook 已注入');
    console.log('[Tip] 也可使用条件断点输入 false 来跳过debugger');
})();
